import { createHash, timingSafeEqual } from "crypto";
import { parse } from "querystring";
class YMNotificationError extends Error {}
/**
 * @template {CallableFunction} T
 *
 * @param {T} function_
 * @return {T}
 */
function promise(function_) {
  const wrapper = (...parameters) => {
    try {
      const result = function_(...parameters);
      if (result instanceof Promise) return result;
      return Promise.resolve(result);
    } catch (error) {
      return Promise.reject(error);
    }
  };
  return wrapper;
}
/**
 * Класс, который реализует [механизм проверки уведомлений от YooMoney](https://yoomoney.ru/docs/wallet/using-api/notification-p2p-incoming#security)
 *
 * @see {@link https://yoomoney.ru/docs/wallet/using-api/notification-p2p-incoming#security|Описание механизма}
 * @export
 * @class NotificationChecker
 */
class NotificationChecker {
  /**
   * Creates an instance of NotificationChecker.
   * @param {string} secret Секретное слово
   * @memberof NotificationChecker
   */
  constructor(secret) {
    this.secret = secret;
  }
  /**
   * Проверяет полученное уведомление и возвращает типизированную версию
   *
   * @throws {YMNotificationError} Если хеш уведомления не совпадает
   * @param {Object} notification Объект уведомления
   * @return {NotificationDTO}
   * @memberof NotificationChecker
   */
  check(notification) {
    const notificationWithSecret = {
      ...notification,
      notification_secret: this.secret
    };
    const pattern =
      "notification_type&operation_id&amount&currency&datetime&sender&codepro&notification_secret&label";
    const signature = pattern
      .split("&")
      .map((key) => notificationWithSecret[key])
      .join("&");
    const hash = createHash("sha1").update(signature).digest();
    if (!timingSafeEqual(hash, Buffer.from(notification.sha1_hash, "hex"))) {
      throw new YMNotificationError(`Notification hash mismatch`);
    }
    return {
      ...notification,
      amount: Number.parseFloat(notification.amount),
      notification_type: notification.notification_type,
      withdraw_amount: Number.parseFloat(notification.withdraw_amount) || 0,
      currency: notification.currency,
      codepro: Boolean(notification.codepro),
      test_notification: Boolean(notification.test_notification),
      unaccepted: Boolean(notification.unaccepted)
    };
  }
  /**
   *
   * `[Экспериментально]` Упрощает интеграцию с `express`
   *
   * #### Это middleware кидает ошибки, позаботьтесь об их обработке
   *
   * @param {Object} [options={}] Параметры обработки запроса
   * @param {boolean} [options.memo=true] Флаг для включения/отключения пропуска повторяющихся запросов, если один из них был успешно обработан
   * @memberof NotificationChecker
   * @param {RequestHandler<Record<string, string>, any, NotificationDTO>=} actualHandler
   * @return {RequestHandler}
   *
   * ##### Пример:
   * **В начале файла**
   * ```js
   * const nc = new YMNotificationChecker(process.env.YM_SECRET);
   *
   * ```
   * *`Вариант 1 - Классический`*
   *
   * ```js
   * app.post('/webhook/yoomoney', nc.middleware(), (req, res) => {
   *  req.body // Это `NotificationDTO`
   * })
   * ```
   *
   * *`Вариант 2 - Если нужны подсказки типов`*
   *
   * ```js
   * app.post('/webhook/yoomoney', nc.middleware({}, (req, res) => {
   *  req.body // Это `NotificationDTO`
   * }))
   * ```
   *
   *  **Обработка ошибок**
   * ```js
   * app.use((error, request, response, next) => {
   *  console.log(error); // [YMNotificationError: Notification hash mismatch]
   * })
   * ```
   */
  middleware(options = {}, actualHandler = (_request, _response, next) => next()) {
    const calls = new Set();
    const { memo = true } = options;
    return async (request, response, next) => {
      let body = {};
      if (!request.body) {
        const text = await new Promise((resolve, reject) => {
          let accumulated = "";
          request.on("error", (error) => reject(error));
          request.on("data", (data) => (accumulated += String(data)));
          request.on("end", () => resolve(accumulated));
        });
        body = parse(text);
      }
      if (typeof request.body === "object") {
        body = request.body;
      }
      const key = body.sha1_hash;
      if (memo && calls.has(key)) return next();
      try {
        const notification = this.check(body);
        request.body = notification;
      } catch (error) {
        return next(error);
      }
      if (!memo) return actualHandler(request, response, next);
      await promise(actualHandler)(request, response, next);
      calls.add(key);
    };
  }
}
export { NotificationChecker, YMNotificationError };
